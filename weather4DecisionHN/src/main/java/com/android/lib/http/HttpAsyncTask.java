package com.android.lib.http;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.io.UnsupportedEncodingException;import java.net.HttpURLConnection;import java.net.MalformedURLException;import java.net.URL;import java.net.URLEncoder;import java.util.Iterator;import java.util.Map;import java.util.Set;import javax.net.ssl.HostnameVerifier;import javax.net.ssl.HttpsURLConnection;import javax.net.ssl.SSLContext;import javax.net.ssl.SSLSession;import javax.net.ssl.TrustManager;import javax.net.ssl.X509TrustManager;import android.os.Handler;import android.text.TextUtils;import android.util.Log;public abstract class HttpAsyncTask extends Thread {    private final Handler handler = new Handler();    private final static int TIME_OUT = 20000;    private String url = null;    private String params = null;    private String encode = "UTF-8";    private boolean canceled = false;    private boolean debug = false;    private HttpURLConnection conn = null;    private String method = "GET";    private String taskId;    public abstract void onStart(String taskId);    public abstract void onFinish(String taskId, String response);    public void excute(String url, Map<String, String> map) {        this.url = url;        this.params = buildParams(map);        this.start();    }    public void excute(String url, Map<String, String> map, String method) {        this.url = url;        this.params = buildParams(map);        this.method = method;        this.start();    }    public void excute(String url, String params) {        this.url = url;        this.params = params;        this.start();    }    public void excute(String url, String params, String method) {        this.url = url;        this.params = params;        this.method = method;        this.start();    }    public HttpAsyncTask() {        this.taskId = this.getId() + "";    }    public HttpAsyncTask(String taskId) {        super(taskId);        if (TextUtils.isEmpty(taskId)) {            taskId = this.getId() + "";        }        this.taskId = taskId;    }    public void setDebug(boolean debug) {        this.debug = debug;    }    /**     * 取消请求     */    public void cancel() {        try {            canceled = true;            if (conn != null) {                conn.disconnect();                conn = null;            }            if (debug) {                Log.e(this.getClass().getSimpleName(), "request is canceled , task id is ---> " + taskId);            }        } catch (Exception e) {            Log.d(this.getClass().getSimpleName(), e.toString());        }    }    /**     * encode     *     * @return the encode     */    public String getEncode() {        return encode;    }    /**     * @param encode the encode to set     */    public void setEncode(String encode) {        this.encode = encode;    }    @Override    public void run() {        handler.post(new Runnable() {            @Override            public void run() {                onStart(taskId);            }        });        if (debug) {            Log.e(this.getClass().getSimpleName(), "========================================================");            Log.e(this.getClass().getSimpleName(), "request url is ---> " + url);            Log.e(this.getClass().getSimpleName(), "request method is ---> " + method);            Log.e(this.getClass().getSimpleName(), "request params is ---> " + params);        }        StringBuffer result = new StringBuffer();        ByteArrayOutputStream data = null;        InputStream is = null;        try {            boolean isPost = method.equalsIgnoreCase("POST");            if (!isPost) {                url = (url.indexOf("?") == -1 && !TextUtils.isEmpty(params)) ? url + "?" : url;                url = url + params;            }            if (url.startsWith("https")) {                trustAllHosts();                HttpsURLConnection conns = (HttpsURLConnection) new URL(url).openConnection();                conns.setHostnameVerifier(DO_NOT_VERIFY);                conn = conns;            } else {                conn = (HttpURLConnection) new URL(url).openConnection();            }            conn.setRequestMethod(method);            conn.setRequestProperty("User-Agent", "Android");            conn.setRequestProperty("Connection", "Keep-Alive");            conn.setConnectTimeout(TIME_OUT);            conn.setReadTimeout(TIME_OUT);            conn.setInstanceFollowRedirects(true);            conn.setDoOutput(isPost);            conn.setDoInput(true);            conn.connect();            if (isPost) {                OutputStream outStream = conn.getOutputStream();                if (params != null) {                    outStream.write(params.getBytes(encode));                }                outStream.flush();                outStream.close();            }            int code = conn.getResponseCode();            if (code == 302) {                String location = conn.getHeaderField("location");                this.url = location;                run();                if (debug) {                    Log.e(this.getClass().getSimpleName(), "request edirect, the new url is ---> " + url);                }                return;            }            if (code == 200) {                is = conn.getInputStream();                data = new ByteArrayOutputStream();                int read = 0;                byte[] buffer = new byte[128];                while ((read = is.read(buffer)) > 0) {                    data.write(buffer, 0, read);                }                result.append(data.toString(encode));            } else {                result.append("request error, the code is ---> " + code);            }        } catch (MalformedURLException e1) {            result.append(e1.toString());        } catch (UnsupportedEncodingException e2) {            result.append(e2.toString());        } catch (IOException e3) {            result.append(e3.toString());        } finally {            try {                if (null != data) {                    data.flush();                    data.close();                }                if (is != null) {                    is.close();                }            } catch (IOException e) {                result.append(e.toString());            }            if (conn != null) {                conn.disconnect();                conn = null;            }        }        if (!canceled) {            if (debug) {                Log.e(this.getClass().getSimpleName(), "request finish, response is ---> " + result.toString());            }            final String ret = result.toString();            handler.post(new Runnable() {                @Override                public void run() {                    onFinish(taskId, ret);                }            });        }    }    /**     * 组装参数Map     *     * @param paramsMap     * @return String     */    private String buildParams(Map<String, String> paramsMap) {        if (paramsMap == null || paramsMap.size() == 0) {            return "";        }        StringBuilder params = new StringBuilder();        Set<String> keySet = paramsMap.keySet();        Iterator<String> iterator = keySet.iterator();        while (iterator.hasNext()) {            String key = iterator.next();            String value = paramsMap.get(key);            params.append(key + "=" + encode(value) + "&");        }        return params.toString().substring(0, params.toString().length() - 1);    }    /**     * 对参数进行转码     *     * @param value     * @return String     */    private String encode(String value) {        String encoded = null;        try {            encoded = URLEncoder.encode(value, "UTF-8");        } catch (UnsupportedEncodingException ignore) {        }        StringBuffer buf = new StringBuffer(encoded.length());        char focus;        for (int i = 0; i < encoded.length(); i++) {            focus = encoded.charAt(i);            if (focus == '*') {                buf.append("%2A");            } else if (focus == '+') {                buf.append("%20");            } else if (focus == '%' && (i + 1) < encoded.length() && encoded.charAt(i + 1) == '7' && encoded.charAt(i + 2) == 'E') {                buf.append('~');                i += 2;            } else if (focus == '%' && (i + 1) < encoded.length() && encoded.charAt(i + 1) == '7' && encoded.charAt(i + 2) == 'C') {                buf.append('|');                i += 2;            } else {                buf.append(focus);            }        }        return buf.toString();    }    //---------HTTPS信任所有证书---------------    private void trustAllHosts() {        // Create a trust manager that does not validate certificate chains        // Android 采用X509的证书信息机制        TrustManager[] trustAllCerts = new TrustManager[]{                new X509TrustManager() {                    public java.security.cert.X509Certificate[] getAcceptedIssuers() {                        return new java.security.cert.X509Certificate[]{};                    }                    @Override                    public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) throws java.security.cert.CertificateException {                    }                    @Override                    public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) throws java.security.cert.CertificateException {                    }                }        };        // Install the all-trusting trust manager        try {            SSLContext sc = SSLContext.getInstance("TLS");            sc.init(null, trustAllCerts, new java.security.SecureRandom());            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());        } catch (Exception e) {            e.printStackTrace();        }    }    private final HostnameVerifier DO_NOT_VERIFY = new HostnameVerifier() {        public boolean verify(String hostname, SSLSession session) {            return true;        }    };}